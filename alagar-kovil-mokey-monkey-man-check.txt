// Multi-person Pose Viewer + Auto Compare (All Pairs) + Per-Person CSV (x,y,z)
// Extended: Horizontal draggable line that interacts with keypoints and shows biomechanical vectors/angles
// Usage: place this in your p5 sketch JS file. Ensure p5.js is loaded.
// Keep your JSON filename and video names in preload().

const FPS = 30;
const POSE_W = 640, POSE_H = 480;
const EDGES = [
  [5,7],[7,9],[6,8],[8,10],
  [11,13],[13,15],[12,14],[14,16],
  [5,6],[11,12],[5,11],[6,12]
];

let app;

function preload(){
  // pass your filenames here (replace if needed)
  app = new App('NAYAKANN.mp4', 'sathyapottapjhadiyudhu.json', 'unnamed.jpg');
  app.preload();
}
function setup(){ createCanvas(1280,720); frameRate(FPS); app.setup(); }
function draw(){ app.tick(); }
function mousePressed(){ app.onMousePressed(); }
function mouseDragged(){ app.onMouseDragged(); }
function mouseReleased(){ app.onMouseReleased(); }
function keyPressed(){ app.onKey(key.toUpperCase()); }
function mouseWheel(e){ return true; }

// ---------------- App ----------------
class App {
  constructor(videoFile, poseJSONFile, headFile){
    this.videoFile = videoFile;
    this.poseJSONFile = poseJSONFile;
    this.headFile = headFile;

    // media
    this.video = null;
    this.headImg = null;
    this.videoReady = false;

    // json & parsed frames
    this.rawJSON = null;
    this.frameEntries = [];         // normalized sorted by frame_id
    this.poseMap = new Map();
    this.jsonReady = false;
    this.anyDrawReady = false;
    this.kpCount = 0;

    // playback/time
    this.t = 0;
    this.playing = false;
    this.rate = 1;

    // view / overlay
    this.scaleCycle = [1,0.75,0.5,0.25];
    this.scaleIdx = 0; this.scale = this.scaleCycle[this.scaleIdx];
    this.pointSizes = [6,12,18,24,36];
    this.ptIdx = 1; this.ptSize = this.pointSizes[this.ptIdx];
    this.offset = { x:0, y:0 };
    this.drag = { on:false, dx:0, dy:0 };
    this.showLabels = false;
    this.alpha = 200;

    // rose control
    this.roseEmoji = 'ðŸŒ¹';
    this.roseScale = 1;
    this.roseBasePx = 24;
    this.roseYOffset = 0.5;
    this.roseKeypoint = 10;
    this.roseOnAll = false;

    // connector / comparison features (manual view)
    this.showVideo = true;
    this.connectAll = false;
    this.pairA = [1,2];
    this.pairB = [3,4];
    this.similarity = { avgSimilarityPct: null, avgAngleDeg: null, avgLenRatio: null, validCount: 0 };

    // auto compare (all pairs)
    this.autoMode = false;
    this.thresholdPct = 80;
    this.allPairs = [];          // list of [i,j] with i<j
    this.comparePlan = [];       // list of {A:[i,j], B:[k,l]}
    this.planIdx = 0;            // current index into comparePlan
    this.autoBusy = false;       // avoid double exports same frame
    this.autoProgressText = '';
    this._lastExportStamp = 0;   // throttle

    // NEW: accumulators & batch control for combined export runs
    this._combinedLines = null;   // combined comparison CSV lines
    this._hitLines = null;        // combined hit CSV lines
    this._autoBatchSize = 6;      // how many compare jobs to process per tick
    this._autoRunCooldown = 1000; // cooldown between finished runs (ms)
    this._autoRunId = 0;

    // trails
    this.trails = {};
    this.showTrails = true;
    this.maxTrail = 240;
    this.trailAlpha = 160;
    this.trailWeight = 3;
    this.trailColors = [[0,200,255],[255,80,0],[0,255,120],[255,200,0],[180,120,255],[255,0,180]];
    this.trailSkip = 1;

    // caches
    this._vw = 0; this._vh = 0; this._scaleX = 1; this._scaleY = 1;
    this._lastPoseFrame = -1;

    // UI
    this.ui = new UI();
    this.param = { speed:1.0, alpha:this.alpha, tlen:this.maxTrail, twidth:this.trailWeight, start:0.0, dur:2.0 };

    // autoplay-safe init
    this.inited = false;
    this.initBtn = new UIButton(width/2 - 100, height/2 - 32, 200, 'Start / Init', ()=>this._userInit());

    // ---------- HLine interaction & biomechanics config ----------
    // Horizontal draggable line (y in canvas coords)
    this.hline = new HLine(POSE_H/2 * (height/POSE_H), height * 0.5); // init relative to canvas height
    this.intersectThreshold = 12; // px threshold for "intersection" with a keypoint (in pose space, scaled)
    // configurable keypoint indices for biomech checks (default COCO mapping guesses)
    this.cfg = {
      leftHip: 11, leftKnee: 13, leftAnkle: 15,
      rightHip: 12, rightKnee: 14, rightAnkle: 16,
      leftShoulder: 5, leftElbow: 7, leftWrist: 9,
      rightShoulder: 6, rightElbow: 8, rightWrist: 10
    };
    this.showBiomech = true;
    this.forceScale = 36; // visual scale of force arrows (tweak)
  }

  preload(){
    loadJSON(this.poseJSONFile, (data) => {
      this.rawJSON = data;
      const entries = Array.isArray(data) ? data : Object.values(data);
      this.frameEntries = [];
      for (let i = 0; i < entries.length; i++){
        const e = entries[i];
        const fid = Number(e.frame_id ?? e.frameId ?? e.frame);
        if (!Number.isFinite(fid)) continue;
        let persons = e.persons ?? e.keypoints ?? e.kpts ?? e.people ?? e.pose;
        if (!persons) continue;
        // If keypoints are flattened or single person, normalize
        // Expecting persons: either [[ [x,y,z?], ...], ...] or flattened array
        if (Array.isArray(persons) && persons.length && typeof persons[0] === 'number') {
          // possibly flattened single-person list: x,y,score,x,y,score...
          const kpts = [];
          for (let p=0;p<persons.length;p+=3) {
            const x = persons[p], y = persons[p+1], z = persons[p+2] ?? 1;
            kpts.push([x,y,z]);
          }
          persons = [kpts];
        } else if (Array.isArray(persons) && persons.length && Array.isArray(persons[0]) && typeof persons[0][0] === 'number' && typeof persons[0][1] === 'number') {
          // either single person kpt array [ [x,y,z], ... ] OR array-of-persons already
          if (!Array.isArray(persons[0][0])) {
            // single person array -> wrap
            persons = [persons];
          }
        } else if (Array.isArray(persons) && persons.length && Array.isArray(persons[0]) && Array.isArray(persons[0][0])) {
          // persons already array-of-person-arrays -> ok
        } else {
          // unknown format: try to coerce
          persons = [persons];
        }

        // normalize: keep [x,y,z] but allow nulls
        const personsNorm = persons.map(ps => (Array.isArray(ps) ? ps.map(p => (p && Array.isArray(p) ? p : null)) : []));
        this.frameEntries.push({ frame_id: fid, persons: personsNorm, rawEntry: e });
        this.poseMap.set(fid, personsNorm);
        this._lastPoseFrame = max(this._lastPoseFrame, fid);
      }
      this.frameEntries.sort((a,b)=>a.frame_id - b.frame_id);
      if (this.frameEntries.length){
        // estimate keypoint count = max across all entries
        let m = 0;
        for (let i=0; i<this.frameEntries.length; i++){
          const ex = this.frameEntries[i].persons;
          if (ex && ex.length){
            for(let p=0;p<ex.length;p++) m = max(m, ex[p].length);
          }
        }
        this.kpCount = m;
      }
      this._buildAllPairsAndPlan();
      this.jsonReady = true;
      this.anyDrawReady = true;
      console.log('Loaded JSON, frames:', this.frameEntries.length, 'lastFrame=', this._lastPoseFrame, 'kpCount=', this.kpCount, 'pairs=', this.allPairs.length, 'plan=', this.comparePlan.length);
    }, (err)=>{
      console.warn('Failed to load JSON:', err);
      this.rawJSON = null;
      this.jsonReady = false;
      this.anyDrawReady = false;
    });

    this.headImg = loadImage(this.headFile, ()=>{}, ()=>{ this.headImg = null; });
  }

  setup(){
    // create a muted, hidden looping video element. Play will be triggered by user init to satisfy autoplay rules.
    try {
      this.video = createVideo([this.videoFile], ()=>{
        this.video.hide();
        this.video.elt.muted = true;
        this.video.elt.playsInline = true;
        this.video.volume = 0;
        this.video.speed(this.rate);
        this.videoReady = true;
        console.log('Video element created.');
      }, (err)=>{
        console.warn('Video load failed:', err);
        this.videoReady = false;
      });
    } catch(e){
      console.warn('createVideo failed:', e);
      this.videoReady = false;
    }

    this._buildUI();
  }

  _userInit(){
    this.inited = true;
    if (this.video && this.videoReady){
      try { this.video.loop(); this.video.hide(); this.video.speed(this.rate); } catch(e){ console.warn(e); }
    }
    this.playing = true;
  }

  _buildAllPairsAndPlan(){
    this.allPairs = [];
    for (let i=0;i<this.kpCount;i++){
      for (let j=i+1;j<this.kpCount;j++){
        this.allPairs.push([i,j]);
      }
    }
    this.comparePlan = [];
    for (let ia=0; ia<this.allPairs.length; ia++){
      for (let ib=ia+1; ib<this.allPairs.length; ib++){
        const A = this.allPairs[ia], B = this.allPairs[ib];
        this.comparePlan.push({A:[A[0],A[1]], B:[B[0],B[1]]});
      }
    }
    this.planIdx = 0;
  }

  tick(){
    background(18);

    if (!this.anyDrawReady){
      this._drawStatus('Waiting for pose JSONâ€¦ Add JSON to the project.');
      this.initBtn.draw();
      this.ui.draw();
      return;
    }

    // advance time if playing
    if (this.playing){
      const dt = min(1/15, deltaTime / 1000); // avoid large jumps
      this.t += dt * this.rate;
      if (this.video && this.videoReady && this.inited){
        try {
          const vt = this.video.time();
          if (Math.abs(vt - this.t) > 0.12) {
            this.t = vt;
          } else {
            this.video.time(this.t);
          }
        } catch(e){}
      }
    }

    const aspect = POSE_W / POSE_H;
    this._vh = height;
    this._vw = this._vh * aspect;
    this._scaleX = this._vw / POSE_W;
    this._scaleY = this._vh / POSE_H;

    // video background (left area)
    if (this.showVideo && this.video && this.videoReady && this.inited){
      try { image(this.video, 0, 0, this._vw, this._vh); } catch(e){}
    } else {
      push(); noStroke(); fill(30); rect(0,0,this._vw,this._vh);
      fill(160); textAlign(CENTER,CENTER); textSize(16);
      text(this.videoReady ? 'Click "Start / Init" to play video' : 'No video â€” running in no-video mode', this._vw/2, this._vh/2);
      pop();
    }

    // draw horizontal line (in left area coordinates)
    this.hline.draw(this._vw, this._vh, this.offset, this.scale);

    // trails + pose overlay
    if (this.showTrails) this._drawTrails();
    this._drawPose();

    // compute + draw similarity using improved method
    this._computeSimilarity();
    this._drawSimilarityOverlay();

    // auto compare (batched combined runs)
    this._autoCompareTick();

    if (this.videoReady && !this.inited) this.initBtn.draw();

    this.ui.draw();
  }

  _drawStatus(msg){ push(); fill(255); textAlign(CENTER,CENTER); textSize(18); text(msg, width/2, height/2 - 60); pop(); }

  _getDesiredFrameForTime(){ return Math.round(this.t * FPS); }

  _findEntryForFrame(frameNum){
    const arr = this.frameEntries;
    if (!arr.length) return null;
    // binary search for nearest <= frameNum
    let lo = 0, hi = arr.length - 1, best = null;
    while (lo <= hi){
      const mid = (lo + hi) >> 1;
      const fid = arr[mid].frame_id;
      if (fid === frameNum){ best = arr[mid]; break; }
      if (fid < frameNum){ best = arr[mid]; lo = mid + 1; }
      else { hi = mid - 1; }
    }
    return best || arr[0];
  }

  _getCurrentPersons(){
    const desired = this._getDesiredFrameForTime();
    const entry = this._findEntryForFrame(desired);
    return entry ? entry.persons : [];
  }

  _drawPose(){
    const persons = this._getCurrentPersons();
    const lblSize = max(10, 14 / this.scale);

    push();
    translate(this.offset.x, this.offset.y);
    scale(this.scale);

    // bones
    stroke(255,255,0,this.alpha); strokeWeight(max(3, 4/this.scale)); noFill();
    for (let pi = 0; pi < persons.length; pi++){
      const k = persons[pi];
      for (let e = 0; e < EDGES.length; e++){
        const a = k[EDGES[e][0]], b = k[EDGES[e][1]];
        if (!a || !b) continue;
        line(a[0] * this._scaleX, a[1] * this._scaleY, b[0] * this._scaleX, b[1] * this._scaleY);
      }
    }

    // connect all (polyline)
    if (this.connectAll){
      for (let pi = 0; pi < persons.length; pi++){
        const k = persons[pi];
        strokeWeight(max(1, 2/this.scale));
        const c = this.trailColors[pi % this.trailColors.length];
        stroke(c[0], c[1], c[2], max(90,this.alpha/1.2));
        noFill();
        beginShape();
        for (let i = 0; i < k.length; i++){
          const pt = k[i];
          if (!pt) continue;
          vertex(pt[0] * this._scaleX, pt[1] * this._scaleY);
        }
        endShape();
      }
    }

    // joints + pair lines + rose
    for (let pi = 0; pi < persons.length; pi++){
      const k = persons[pi];
      const c = this.trailColors[pi % this.trailColors.length];
      noStroke(); fill(c[0], c[1], c[2], this.alpha);
      for (let i = 0; i < k.length; i++){
        const pt = k[i];
        if (!pt) continue;
        const x = pt[0] * this._scaleX, y = pt[1] * this._scaleY;
        ellipse(x, y, this.ptSize);
        if (this.showLabels){
          fill(255,255,255, max(90, this.alpha - 30));
          textSize(lblSize); text(i.toString(), x, y - this.ptSize);
          fill(c[0], c[1], c[2], this.alpha);
        }
        if (i === 0 && this.headImg){
          push(); imageMode(CENTER); tint(255, this.alpha);
          const hs = 100 * this.scale; image(this.headImg, x, y - hs/2, hs, hs); pop();
        }
      }

      // draw pair A and B (per-person)
      const a0 = k[this.pairA[0]], a1 = k[this.pairA[1]];
      const b0 = k[this.pairB[0]], b1 = k[this.pairB[1]];
      strokeWeight(max(2, 3/this.scale));
      if (a0 && a1){
        stroke(0,200,255,220); line(a0[0]*this._scaleX, a0[1]*this._scaleY, a1[0]*this._scaleX, a1[1]*this._scaleY);
        noStroke(); fill(0,200,255,220); ellipse(a0[0]*this._scaleX, a0[1]*this._scaleY, this.ptSize/1.2); ellipse(a1[0]*this._scaleX, a1[1]*this._scaleY, this.ptSize/1.2);
      }
      if (b0 && b1){
        stroke(255,140,50,220); line(b0[0]*this._scaleX, b0[1]*this._scaleY, b1[0]*this._scaleX, b1[1]*this._scaleY);
        noStroke(); fill(255,140,50,220); ellipse(b0[0]*this._scaleX, b0[1]*this._scaleY, this.ptSize/1.2); ellipse(b1[0]*this._scaleX, b1[1]*this._scaleY, this.ptSize/1.2);
      }

      // rose
      if (this.roseOnAll){
        const kp = k[this.roseKeypoint];
        if (kp){
          const rx = kp[0] * this._scaleX, ry = kp[1] * this._scaleY;
          push(); textAlign(CENTER, CENTER); textSize(this.roseBasePx * this.roseScale); fill(255,255,255,this.alpha);
          text(this.roseEmoji, rx, ry - (this.ptSize * this.roseYOffset)); pop();
        }
      }

      // --- biomechanics check intersection with horizontal line and draw vectors ---
      if (this.showBiomech) this._processBiomechanicsForPerson(k, pi);
    }

    pop();

    // update trails using nearest entry
    const desired = this._getDesiredFrameForTime();
    const entry = this._findEntryForFrame(desired);
    const personsEntry = entry ? entry.persons : [];
    this._updateTrails(entry ? entry.frame_id : desired, personsEntry);
  }

  // ---------------- Biomechanics interaction & drawing ----------------
  _processBiomechanicsForPerson(k, personIndex){
    const lineYCanvas = this.hline.y; // already canvas coords
    const toCanvas = (pt) => ({ x: (pt[0] * this._scaleX * this.scale) + this.offset.x, y: (pt[1] * this._scaleY * this.scale) + this.offset.y });

    const sets = [
      { name: 'LLEG', hip: this.cfg.leftHip, knee: this.cfg.leftKnee, ankle: this.cfg.leftAnkle, color: [0,200,255] },
      { name: 'RLEG', hip: this.cfg.rightHip, knee: this.cfg.rightKnee, ankle: this.cfg.rightAnkle, color: [255,80,0] },
      { name: 'LARM', shoulder: this.cfg.leftShoulder, elbow: this.cfg.leftElbow, wrist: this.cfg.leftWrist, color: [0,255,120] },
      { name: 'RARM', shoulder: this.cfg.rightShoulder, elbow: this.cfg.rightElbow, wrist: this.cfg.rightWrist, color: [255,200,0] }
    ];

    for (const s of sets){
      // legs
      if (s.knee !== undefined && s.ankle !== undefined) {
        const kpK = k[s.knee], kpA = k[s.ankle], kpH = k[s.hip];
        if (!kpK || !kpA) continue;
        const cK = toCanvas(kpK), cA = toCanvas(kpA);
        const d = Math.abs(cK.y - lineYCanvas);
        if (d <= (this.intersectThreshold * this.scale)) {
          const limb = { x: cA.x - cK.x, y: cA.y - cK.y };
          const limbLen = Math.sqrt(limb.x*limb.x + limb.y*limb.y) + 1e-6;
          const perp = { x: -limb.y / limbLen, y: limb.x / limbLen };
          let angleDeg = null;
          if (kpH) {
            const v1 = { x: (kpH[0]*this._scaleX*this.scale + this.offset.x) - cK.x, y: (kpH[1]*this._scaleY*this.scale + this.offset.y) - cK.y };
            const v2 = { x: cA.x - cK.x, y: cA.y - cK.y };
            angleDeg = this._angleBetweenVectorsDeg(v1, v2);
          } else angleDeg = 0;
          const angleScore = Math.max(0, Math.min(1, (180 - Math.abs(angleDeg - 180)) / 180));
          const lengthScore = Math.max(0, Math.min(1, limbLen / (this.forceScale * 3)));
          const mag = (0.4 * angleScore + 0.6 * lengthScore);
          const origin = cA;
          const tip = { x: origin.x + perp.x * mag * this.forceScale, y: origin.y + perp.y * mag * this.forceScale };

          push();
          strokeWeight(2);
          const col = s.color;
          stroke(col[0], col[1], col[2], 220);
          fill(col[0], col[1], col[2], 200);
          line(origin.x, origin.y, tip.x, tip.y);
          push();
          translate(tip.x, tip.y);
          const ang = Math.atan2(perp.y, perp.x);
          rotate(ang);
          triangle(0,0, -8,-5, -8,5);
          pop();
          noStroke(); fill(255); textSize(12); textAlign(LEFT, CENTER);
          text(`${s.name} angle:${angleDeg !== null ? angleDeg.toFixed(1) : 'N/A'}Â°`, tip.x + 8, tip.y - 6);
          text(`f:${(mag).toFixed(2)}`, tip.x + 8, tip.y + 8);
          pop();

          push();
          stroke(255,255,255,220); strokeWeight(2); noFill();
          ellipse(cK.x, cK.y, this.ptSize*1.6);
          ellipse(cA.x, cA.y, this.ptSize*1.6);
          pop();
        }
      // arms
      } else if (s.elbow !== undefined && s.wrist !== undefined) {
        const kpE = k[s.elbow], kpW = k[s.wrist], kpS = k[s.shoulder];
        if (!kpE || !kpW) continue;
        const cE = toCanvas(kpE), cW = toCanvas(kpW);
        const d = Math.abs(cE.y - lineYCanvas);
        if (d <= (this.intersectThreshold * this.scale)) {
          const limb = { x: cW.x - cE.x, y: cW.y - cE.y };
          const limbLen = Math.sqrt(limb.x*limb.x + limb.y*limb.y) + 1e-6;
          const perp = { x: -limb.y / limbLen, y: limb.x / limbLen };
          let angleDeg = null;
          if (kpS) {
            const v1 = { x: (kpS[0]*this._scaleX*this.scale + this.offset.x) - cE.x, y: (kpS[1]*this._scaleY*this.scale + this.offset.y) - cE.y };
            const v2 = { x: cW.x - cE.x, y: cW.y - cE.y };
            angleDeg = this._angleBetweenVectorsDeg(v1, v2);
          } else angleDeg = 0;
          const angleScore = Math.max(0, Math.min(1, (180 - Math.abs(angleDeg - 180)) / 180));
          const lengthScore = Math.max(0, Math.min(1, limbLen / (this.forceScale * 3)));
          const mag = (0.4 * angleScore + 0.6 * lengthScore);
          const origin = cW;
          const tip = { x: origin.x + perp.x * mag * this.forceScale, y: origin.y + perp.y * mag * this.forceScale };

          push();
          strokeWeight(2);
          const col = s.color;
          stroke(col[0], col[1], col[2], 220);
          fill(col[0], col[1], col[2], 200);
          line(origin.x, origin.y, tip.x, tip.y);
          push(); translate(tip.x, tip.y); rotate(Math.atan2(perp.y, perp.x));
          triangle(0,0, -8,-5, -8,5);
          pop();
          noStroke(); fill(255);
          textSize(12); textAlign(LEFT, CENTER);
          text(`${s.name} angle:${angleDeg !== null ? angleDeg.toFixed(1) : 'N/A'}Â°`, tip.x + 8, tip.y - 6);
          text(`f:${(mag).toFixed(2)}`, tip.x + 8, tip.y + 8);
          pop();

          push();
          stroke(255,255,255,220); strokeWeight(2); noFill();
          ellipse(cE.x, cE.y, this.ptSize*1.6);
          ellipse(cW.x, cW.y, this.ptSize*1.6);
          pop();
        }
      }
    }
  }

  _angleBetweenVectorsDeg(a, b){
    const ax = a.x, ay = a.y, bx = b.x, by = b.y;
    const dot = ax*bx + ay*by;
    const na = Math.sqrt(ax*ax + ay*ay) + 1e-9;
    const nb = Math.sqrt(bx*bx + by*by) + 1e-9;
    let cosv = dot / (na * nb);
    cosv = Math.max(-1, Math.min(1, cosv));
    const angleRad = Math.acos(cosv);
    return angleRad * (180/Math.PI);
  }

  // ---------------- Improved similarity: procrustes-like ----------------
  _similarityForPairPoints(a0,a1,b0,b1){
    if (!a0 || !a1 || !b0 || !b1) return null;
    const A0 = complex(a0[0], a0[1]);
    const A1 = complex(a1[0], a1[1]);
    const B0 = complex(b0[0], b0[1]);
    const B1 = complex(b1[0], b1[1]);

    const Ac = complexScale(complexAdd(A0, A1), 0.5);
    const Bc = complexScale(complexAdd(B0, B1), 0.5);

    const A0c = complexSub(A0, Ac);
    const A1c = complexSub(A1, Ac);
    const B0c = complexSub(B0, Bc);
    const B1c = complexSub(B1, Bc);

    const num = complexAdd(complexMul(complexConj(B0c), A0c), complexMul(complexConj(B1c), A1c));
    const den = (complexAbs2(B0c) + complexAbs2(B1c));
    if (den < 1e-9) return null;

    const mu = complexScale(num, 1/den);
    const scale = complexAbs(mu);
    const rotDeg = Math.atan2(mu.im, mu.re) * (180/Math.PI);

    const R0 = complexSub(A0c, complexMul(mu, B0c));
    const R1 = complexSub(A1c, complexMul(mu, B1c));
    const rms = Math.sqrt((complexAbs2(R0) + complexAbs2(R1))/2);

    const refLen = Math.sqrt((complexAbs2(A0c) + complexAbs2(A1c))/2);
    const norm = refLen + 1e-6;
    const normalizedError = rms / norm;
    const similarityPct = Math.max(0, Math.min(100, 100 * Math.exp(- (normalizedError * 2.5)) ));

    return {
      similarityPct,
      scale,
      rotationDeg: rotDeg,
      residualRMS: rms,
      normalizedError
    };
  }

  _computeSimilarityForEntryWithPairs(entry, pairA, pairB){
    if (!entry) return { avgSimilarityPct: null, validCount: 0, meanScale: null, meanRotation: null };
    const persons = entry.persons;
    let sims = [], scales = [], rots = [], val=0;
    for (let p = 0; p < persons.length; p++){
      const k = persons[p];
      const a0 = k[pairA[0]], a1 = k[pairA[1]];
      const b0 = k[pairB[0]], b1 = k[pairB[1]];
      const res = this._similarityForPairPoints(a0,a1,b0,b1);
      if (!res) continue;
      sims.push(res.similarityPct);
      scales.push(res.scale);
      rots.push(res.rotationDeg);
      val++;
    }
    if (val === 0) return { avgSimilarityPct: null, validCount: 0, meanScale: null, meanRotation: null };
    const avgSim = sims.reduce((s,x)=>s+x,0)/sims.length;
    const meanScale = scales.reduce((s,x)=>s+x,0)/scales.length;
    const meanRot = rots.reduce((s,x)=>s+x,0)/rots.length;
    return { avgSimilarityPct: avgSim, validCount: val, meanScale: meanScale, meanRotation: meanRot };
  }

  _computeSimilarity(){
    const desired = this._getDesiredFrameForTime();
    const entry = this._findEntryForFrame(desired);
    if (!entry){ this.similarity = { avgSimilarityPct: null, validCount: 0 }; return; }
    const sim = this._computeSimilarityForEntryWithPairs(entry, this.pairA, this.pairB);
    this.similarity = { avgSimilarityPct: sim.avgSimilarityPct, validCount: sim.validCount, meanScale: sim.meanScale, meanRotation: sim.meanRotation };
  }

  _drawSimilarityOverlay(){
    push();
    const pad = 10;
    const x = 8, y = 8;
    fill(0,0,0,160); rect(x, y, 520, 144, 6);
    fill(220); textAlign(LEFT, TOP); textSize(12);
    text(`Frame: ${this._getDesiredFrameForTime()}    Threshold: ${this.thresholdPct}%`, x + pad, y + pad);
    text(`Pair A: ${this.pairA[0]} -> ${this.pairA[1]}    Pair B: ${this.pairB[0]} -> ${this.pairB[1]}`, x + pad, y + pad + 18);
    if (!this.similarity || this.similarity.validCount === 0){
      fill(200); text('No valid persons with both pairs', x + pad, y + pad + 42);
    } else {
      fill(180,255,180); text(`Avg similarity: ${this.similarity.avgSimilarityPct.toFixed(1)}%`, x + pad, y + pad + 42);
      fill(200,220); text(`Valid persons: ${this.similarity.validCount}`, x + pad, y + pad + 64);
      if (this.similarity.meanScale !== null){
        fill(220); text(`Mean scale: ${this.similarity.meanScale.toFixed(3)}    Mean rot: ${this.similarity.meanRotation.toFixed(1)}Â°`, x + pad, y + pad + 84);
      }
    }
    fill(200); textSize(11);
    text(`Auto: ${this.autoMode ? 'RUNNING' : 'OFF'}  |  Plan ${min(this.planIdx+1,this.comparePlan.length)}/${this.comparePlan.length}  |  ${this.autoProgressText}`, x + pad, y + pad + 112);
    pop();
  }

  // ---------------- Auto compare runner (batched combined runs, loops while autoMode true) ----------------
  _autoCompareTick(){
    if (!this.autoMode || !this.jsonReady) return;
    if (!this.comparePlan || this.comparePlan.length === 0) return;

    // initialize accumulators if needed
    if (!this._combinedLines || !this._hitLines) {
      this._combinedLines = ['pairA,pairB,frame_id,time_sec,person_index,similarity_pct,mean_scale,mean_rotation_deg'];
      this._hitLines = ['pairA,pairB,frame_id,time_sec,person_index,similarity_pct,valid_count'];
      this.planIdx = 0;
      this._autoRunId = Date.now();
      this.autoProgressText = 'Combined run started';
    }

    // throttle small ticks
    const now = millis();
    if (now - this._lastExportStamp < 50) {
      // allow small spacing between batches
    }

    // process up to _autoBatchSize jobs this tick
    let cnt = 0;
    while (cnt < this._autoBatchSize && this.planIdx < this.comparePlan.length) {
      const job = this.comparePlan[this.planIdx];
      this.autoProgressText = `Processing ${this.planIdx+1}/${this.comparePlan.length}`;
      this._processCompareJob(job, 0, this._lastPoseFrame + 1);
      this.planIdx++;
      cnt++;
    }

    // if finished a full pass
    if (this.planIdx >= this.comparePlan.length) {
      // save results
      this.saveCombinedComparisonCSV();
      this.saveCombinedHitCSV();

      this._lastExportStamp = millis();
      this.autoProgressText = `Finished run @ ${new Date().toISOString()}. Rows:${this._combinedLines.length-1} Hits:${this._hitLines.length-1}`;

      // cooldown before next run
      const cooldown = this._autoRunCooldown;
      this._lastExportStamp = millis();

      // If autoMode still true, reset accumulators and start next run after cooldown.
      // We'll schedule next run by resetting accumulators immediately but wait for cooldown using _lastExportStamp check.
      // To avoid immediate re-run in the same frame, clear accumulators and set planIdx=0 after a small delay.
      // Here we implement: if still autoMode => reset and leave planIdx=0 to rerun; but force at least _autoRunCooldown before processing again.
      if (this.autoMode) {
        // clear and prepare for next loop, but keep autoMode true
        this._combinedLines = ['pairA,pairB,frame_id,time_sec,person_index,similarity_pct,mean_scale,mean_rotation_deg'];
        this._hitLines = ['pairA,pairB,frame_id,time_sec,person_index,similarity_pct,valid_count'];
        this.planIdx = 0;
        // block immediate work for cooldown period by advancing planIdx unchanged until time passes
        this.autoProgressText = `Cooldown ${Math.round(cooldown/1000)}s before next run`;
        // wait â€” subsequent ticks will continue; we rely on _lastExportStamp to space work in _autoCompareTick's loop boundary
        // To implement cooldown simply skip processing if recent export:
        // guard at top of this function checks millis vs _lastExportStamp (we set below)
        this._lastExportStamp = millis();
      } else {
        // If autoMode switched off externally, just stop and keep accumulators intact
        // (they've already been exported)
      }
    }
  }

  // process one compare job across frames and append to combined buffers
  _processCompareJob(job, startF, endFExcl){
    if (!job || !this._combinedLines) return;
    const pairA = job.A; const pairB = job.B;
    const tagA = `${pairA[0]}-${pairA[1]}`;
    const tagB = `${pairB[0]}-${pairB[1]}`;

    for (let f = startF; f < endFExcl; f++){
      const entry = this._findEntryForFrame(f);
      if (!entry) continue;
      const persons = entry.persons;
      const timeSec = (f / FPS).toFixed(3);
      for (let p = 0; p < persons.length; p++){
        const k = persons[p];
        if (!k) continue;
        const a0 = k[pairA[0]], a1 = k[pairA[1]];
        const b0 = k[pairB[0]], b1 = k[pairB[1]];
        if (!(a0 && a1 && b0 && b1)) continue;
        const res = this._similarityForPairPoints(a0,a1,b0,b1);
        if (!res) continue;
        const line = [
          tagA,
          tagB,
          f,
          timeSec,
          p,
          res.similarityPct.toFixed(4),
          res.scale.toFixed(4),
          res.rotationDeg.toFixed(4)
        ].join(',');
        this._combinedLines.push(line);

        if (res.similarityPct >= this.thresholdPct) {
          const hitLine = [
            tagA,
            tagB,
            f,
            timeSec,
            p,
            res.similarityPct.toFixed(4),
            1
          ].join(',');
          this._hitLines.push(hitLine);
        }
      }
    }
  }

  saveCombinedComparisonCSV(){
    if (!this._combinedLines || this._combinedLines.length <= 1) {
      console.log('No combined comparison rows to save.');
      return;
    }
    const fname = `combined_comparisons_${Date.now()}.csv`;
    saveStrings(this._combinedLines, fname);
    console.log('Saved combined comparison CSV:', fname);
  }

  saveCombinedHitCSV(){
    if (!this._hitLines || this._hitLines.length <= 1) {
      console.log('No combined hit rows to save.');
      return;
    }
    const fname = `combined_hits_${Date.now()}.csv`;
    saveStrings(this._hitLines, fname);
    console.log('Saved combined hit CSV:', fname);
  }

  // ---------------- per-person CSV with coordinates & metrics (kept for manual exports) ----------------
  saveCSVForPairs(pairA, pairB, startSec=0, durationSec=null){
    if (!this.jsonReady) return;
    startSec = max(0, Number(startSec) || 0);
    if (durationSec == null) durationSec = (this._lastPoseFrame + 1)/FPS;
    durationSec = max(0, Number(durationSec) || 0.001);
    const startF = max(0, floor(startSec * FPS));
    const endFExcl = min(floor((startSec + durationSec) * FPS), this._lastPoseFrame + 1);
    const lines = [];
    const header = [
      'frame_id','time_sec','person_index',
      'A0_x','A0_y','A0_z','A1_x','A1_y','A1_z',
      'B0_x','B0_y','B0_z','B1_x','B1_y','B1_z',
      'similarity_pct','mean_scale','mean_rotation_deg'
    ].join(',');
    lines.push(header);

    for (let f = startF; f < endFExcl; f++){
      const entry = this._findEntryForFrame(f);
      if (!entry) continue;
      const persons = entry.persons;
      const tsec = ((f - startF) / FPS).toFixed(3);

      for (let p = 0; p < persons.length; p++){
        const k = persons[p];
        if (!k) continue;
        const a0 = k[pairA[0]], a1 = k[pairA[1]];
        const b0 = k[pairB[0]], b1 = k[pairB[1]];

        let sim='', mscale='', mrot='';
        if (a0 && a1 && b0 && b1){
          const res = this._similarityForPairPoints(a0,a1,b0,b1);
          if (res){
            sim = res.similarityPct.toFixed(4);
            mscale = res.scale.toFixed(4);
            mrot = res.rotationDeg.toFixed(4);
          }
        }

        const a0s = a0 ? [a0[0], a0[1], a0[2]??1] : ['','',''];
        const a1s = a1 ? [a1[0], a1[1], a1[2]??1] : ['','',''];
        const b0s = b0 ? [b0[0], b0[1], b0[2]??1] : ['','',''];
        const b1s = b1 ? [b1[0], b1[1], b1[2]??1] : ['','',''];

        lines.push([
          f, tsec, p,
          a0s[0],a0s[1],a0s[2], a1s[0],a1s[1],a1s[2],
          b0s[0],b0s[1],b0s[2], b1s[0],b1s[1],b1s[2],
          sim, mscale, mrot
        ].join(','));
      }
    }

    const tagA = `${pairA[0]}-${pairA[1]}`;
    const tagB = `${pairB[0]}-${pairB[1]}`;
    saveStrings(lines, `compare_${tagA}_vs_${tagB}_perperson.csv`);
  }

  // ---------------- hit log CSV (frames exceeding threshold) ----------------
  saveHitLogForPairs(pairA, pairB, startSec=0, durationSec=null, thresholdPct=80){
    if (!this.jsonReady) return;
    startSec = max(0, Number(startSec) || 0);
    if (durationSec == null) durationSec = (this._lastPoseFrame + 1)/FPS;
    durationSec = max(0, Number(durationSec) || 0.001);
    const startF = max(0, floor(startSec * FPS));
    const endFExcl = min(floor((startSec + durationSec) * FPS), this._lastPoseFrame + 1);
    const lines = [];
    lines.push('frame_id,time_sec,avg_similarity_pct,valid_count');

    for (let f = startF; f < endFExcl; f++){
      const entry = this._findEntryForFrame(f);
      const sim = this._computeSimilarityForEntryWithPairs(entry, pairA, pairB);
      if (sim.validCount > 0 && sim.avgSimilarityPct >= thresholdPct){
        const timeSec = ((f - startF) / FPS).toFixed(3);
        lines.push([
          f,
          timeSec,
          sim.avgSimilarityPct.toFixed(4),
          sim.validCount
        ].join(','));
      }
    }
    const tagA = `${pairA[0]}-${pairA[1]}`;
    const tagB = `${pairB[0]}-${pairB[1]}`;
    saveStrings(lines, `hits_${tagA}_vs_${tagB}_thr${thresholdPct}.csv`);
  }

  _updateTrails(frameIndex, persons){
    if ((frameIndex % this.trailSkip) !== 0) return;
    for (let pi = 0; pi < persons.length; pi++){
      if (!this.trails[pi]) this.trails[pi] = {};
      const k = persons[pi];
      for (let ki = 0; ki < k.length; ki++){
        const p = k[ki]; if (!p) continue;
        const arr = (this.trails[pi][ki] ||= []);
        arr.push({x: p[0], y: p[1]});
        if (arr.length > this.maxTrail) arr.shift();
      }
    }
  }

  _drawTrails(){
    push(); translate(this.offset.x, this.offset.y); scale(this.scale);
    const baseW = max(1.25, this.trailWeight / this.scale);
    for (const piStr in this.trails){
      const pi = Number(piStr);
      const [r,g,b] = this.trailColors[pi % this.trailColors.length];
      const parts = this.trails[pi];
      for (const kiStr in parts){
        const pts = parts[kiStr];
        if (!pts || pts.length < 2) continue;
        strokeWeight(baseW);
        for (let s = 1; s < pts.length; s++){
          const a = lerp(40, this.trailAlpha, s / pts.length);
          stroke(r, g, b, a);
          const p1 = pts[s-1], p2 = pts[s];
          line(p1.x * this._scaleX, p1.y * this._scaleY, p2.x * this._scaleX, p2.y * this._scaleY);
        }
      }
    }
    pop();
  }

  // ---------------- interaction / UI ----------------
  onKey(k){
    if (k === 'T') this.showTrails = !this.showTrails;
    if (k === 'P') (this.playing ? this.pause() : this.play());
    if (k === 'L') this.showLabels = !this.showLabels;
    if (k === 'C') this.trails = {};
    if (k === 'S') { this.param.start = +((this.t||0).toFixed(2)); this.ui.syncFrom(this); }
  }

  onMousePressed(){
    // give hline priority if inside hit area
    if (this.hline.contains(mouseX, mouseY)) { this.hline.mousePressed(); return; }

    if (this.initBtn.contains(mouseX,mouseY)){ this.initBtn.mousePressed(); return; }
    if (this.ui.mousePressed()) return;

    // drag
    this.drag.on = true;
    this.drag.dx = mouseX - this.offset.x;
    this.drag.dy = mouseY - this.offset.y;
  }

  onMouseDragged(){
    if (this.hline.dragging) { this.hline.mouseDragged(); return; }
    if (!this.drag.on) return; this.offset.x = mouseX - this.drag.dx; this.offset.y = mouseY - this.drag.dy;
  }
  onMouseReleased(){ if (this.initBtn.down) this.initBtn.mouseReleased(); if (this.ui.mouseReleased()) return; this.drag.on = false; if (this.hline.dragging) this.hline.mouseReleased(); }

  _jumpToFrame(frameId){
    this.t = frameId / FPS;
    if (this.video && this.videoReady){
      try { this.video.time(this.t); } catch(e){}
    }
  }

  play(){ this.playing = true; if (this.video && this.videoReady) try { this.video.play(); this.video.speed(this.rate); } catch(e){} }
  pause(){ this.playing = false; if (this.video) try { this.video.pause(); } catch(e){} }
  stop(){ this.playing = false; this.t = 0; if (this.video) try { this.video.pause(); this.video.time(0); } catch(e){} }

  // build bottom UI (includes auto mode + hline controls)
  _buildUI(){
    const y = height - 220;
    const row = (i)=> y + i * 34;
    const right = width - 12;

    this.ui.add(new UIButton(12, row(0), 64, 'Play', ()=>this.play()));
    this.ui.add(new UIButton(80, row(0), 64, 'Pause', ()=>this.pause()));
    this.ui.add(new UIButton(148,row(0),64,'Stop', ()=>this.stop()));
    this.ui.add(new UIButton(216,row(0),72,'Scale', ()=>{
      this.scaleIdx = (this.scaleIdx + 1) % this.scaleCycle.length;
      this.scale = this.scaleCycle[this.scaleIdx];
      this.ptIdx = (this.ptIdx + 1) % this.pointSizes.length;
      this.ptSize = this.pointSizes[this.ptIdx];
    }));
    this.ui.add(new UIButton(294,row(0),120,'Toggle Trails', ()=> this.showTrails = !this.showTrails));
    this.ui.add(new UIButton(420,row(0),120,'Clear Trails', ()=> { this.trails = {}; }));

    // video toggle + connect toggle
    this.ui.add(new UIButton(right - 78, row(0), 66, 'Video', ()=>{ this.showVideo = !this.showVideo; }));
    this.ui.add(new UIButton(right - 160, row(0), 92, 'Connect All', ()=>{ this.connectAll = !this.connectAll; }));

    // Auto mode buttons
    const startAuto = new UIButton(right - 400, row(0), 108, 'Start Auto', ()=>{
      if (!this.jsonReady) return;
      // initialize combined-run accumulators and start
      this._combinedLines = ['pairA,pairB,frame_id,time_sec,person_index,similarity_pct,mean_scale,mean_rotation_deg'];
      this._hitLines = ['pairA,pairB,frame_id,time_sec,person_index,similarity_pct,valid_count'];
      this.planIdx = 0;
      this.autoMode = true; this.autoProgressText = 'Starting combined runâ€¦';
      this._autoRunId = Date.now();
    });
    const stopAuto = new UIButton(right - 286, row(0), 96, 'Stop Auto', ()=>{
      this.autoMode = false; this.autoProgressText = 'Stopped';
      // keep accumulators as-is (they were exported after finish)
    });
    this.ui.add(startAuto); this.ui.add(stopAuto);

    // HLine & biomech toggles
    this.ui.add(new UIButton(right - 170, row(1), 120, 'Toggle HLine', ()=>{ this.hline.visible = !this.hline.visible; }));
    this.ui.add(new UIButton(right - 300, row(1), 120, 'Toggle Biomech', ()=>{ this.showBiomech = !this.showBiomech; }));

    // intersection threshold slider
    this.ui.add(new UILabel(12,row(1),'IntersectPx'));
    this.ui.add(new UISlider(110,row(1),220,2,48,this.intersectThreshold,1,(v)=>{ this.intersectThreshold = v|0; }));

    // force scale slider
    this.ui.add(new UILabel(360,row(1),'ForceScale'));
    this.ui.add(new UISlider(440,row(1),160,8,120,this.forceScale,1,(v)=>{ this.forceScale = v|0; }));

    // batch size slider
    this.ui.add(new UILabel(620,row(1),'Batch'));
    this.ui.add(new UISlider(660,row(1),120,1,64,this._autoBatchSize,1,(v)=>{ this._autoBatchSize = Math.max(1,Math.round(v)); }));

    // some quick save JSON buttons (existing)
    this.ui.add(new UIButton(right-420,row(2),120,'Save 0â€“2s JSON', ()=> this.saveWindowJSON(0,2)));
    this.ui.add(new UIButton(right-294,row(2),120,'Save 0â€“5s JSON', ()=> this.saveWindowJSON(0,5)));
    this.ui.add(new UIButton(right-168,row(2),156,'Save Range JSON', ()=> this.saveWindowJSON(this.param.start, this.param.dur)));

    // keypoint index steppers for leg & arm (row 3)
    const baseX = 12, baseY = row(3);
    this.ui.add(new UILabel(baseX, baseY, 'Left Hip/Knee/Ank'));
    this.ui.add(new UIStepper(baseX+140, baseY, 60, this.cfg.leftHip, 1, 0, 99,(v)=>{ this.cfg.leftHip = Math.round(v); }));
    this.ui.add(new UIStepper(baseX+206, baseY, 60, this.cfg.leftKnee, 1, 0, 99,(v)=>{ this.cfg.leftKnee = Math.round(v); }));
    this.ui.add(new UIStepper(baseX+272, baseY, 60, this.cfg.leftAnkle, 1, 0, 99,(v)=>{ this.cfg.leftAnkle = Math.round(v); }));

    this.ui.add(new UILabel(baseX+360, baseY, 'Right Hip/Knee/Ank'));
    this.ui.add(new UIStepper(baseX+520, baseY, 60, this.cfg.rightHip, 1, 0, 99,(v)=>{ this.cfg.rightHip = Math.round(v); }));
    this.ui.add(new UIStepper(baseX+586, baseY, 60, this.cfg.rightKnee, 1, 0, 99,(v)=>{ this.cfg.rightKnee = Math.round(v); }));
    this.ui.add(new UIStepper(baseX+652, baseY, 60, this.cfg.rightAnkle, 1, 0, 99,(v)=>{ this.cfg.rightAnkle = Math.round(v); }));

    // arm
    this.ui.add(new UILabel(baseX, baseY+36, 'Left Sh/Elb/Wr'));
    this.ui.add(new UIStepper(baseX+140, baseY+36, 60, this.cfg.leftShoulder, 1, 0, 99,(v)=>{ this.cfg.leftShoulder = Math.round(v); }));
    this.ui.add(new UIStepper(baseX+206, baseY+36, 60, this.cfg.leftElbow, 1, 0, 99,(v)=>{ this.cfg.leftElbow = Math.round(v); }));
    this.ui.add(new UIStepper(baseX+272, baseY+36, 60, this.cfg.leftWrist, 1, 0, 99,(v)=>{ this.cfg.leftWrist = Math.round(v); }));

    this.ui.add(new UILabel(baseX+360, baseY+36, 'Right Sh/Elb/Wr'));
    this.ui.add(new UIStepper(baseX+520, baseY+36, 60, this.cfg.rightShoulder, 1, 0, 99,(v)=>{ this.cfg.rightShoulder = Math.round(v); }));
    this.ui.add(new UIStepper(baseX+586, baseY+36, 60, this.cfg.rightElbow, 1, 0, 99,(v)=>{ this.cfg.rightElbow = Math.round(v); }));
    this.ui.add(new UIStepper(baseX+652, baseY+36, 60, this.cfg.rightWrist, 1, 0, 99,(v)=>{ this.cfg.rightWrist = Math.round(v); }));
  }

  // Save a slice of the JSON frames as JSON (same format)
  saveWindowJSON(startSec=0, durSec=2){
    if (!this.jsonReady) return;
    const startF = Math.max(0, Math.floor(startSec * FPS));
    const endFExcl = Math.min(Math.floor((startSec + durSec) * FPS), this._lastPoseFrame + 1);
    const out = [];
    for (let f = startF; f < endFExcl; f++){
      const entry = this._findEntryForFrame(f);
      if (entry) out.push(entry.rawEntry ?? { frame_id: entry.frame_id, persons: entry.persons });
    }
    saveJSON(out, `pose_window_${startF}_to_${endFExcl-1}.json`);
  }
}

// ---------------- HLine: draggable horizontal line class ----------------
class HLine {
  constructor(x, y){
    this.x = x || 0; // leftmost x
    this.y = y || 0; // y in canvas coordinates (global)
    this.w = POSE_W; // in pose-space; when drawing we scale to _vw
    this.visible = true;
    this.dragging = false;
    this.hitRadius = 10;
  }
  draw(vw, vh, offset = {x:0,y:0}, scale = 1.0){
    if (!this.visible) return;
    push();
    // line across left video area
    stroke(255,120,120); strokeWeight(2);
    const lx0 = 0 + offset.x;
    const lx1 = vw + offset.x;
    line(lx0, this.y, lx1, this.y);
    // draw drag handle (right side near UI)
    noStroke(); fill(255,120,120,220);
    rect(lx1 - 36, this.y - 10, 36, 20, 4);
    fill(0); textAlign(CENTER, CENTER); textSize(12);
    text('H', lx1 - 18, this.y);
    pop();
  }
  contains(px, py){
    const right = width;
    if (px >= right - 36 && px <= right && py >= this.y - 12 && py <= this.y + 12) return true;
    if (Math.abs(py - this.y) <= this.hitRadius) return true;
    return false;
  }
  mousePressed(){ this.dragging = true; }
  mouseDragged(){ if (!this.dragging) return; this.y = constrain(mouseY, 8, height - 8); }
  mouseReleased(){ this.dragging = false; }
}

// ---------------- Complex helpers for similarity ----------------
function complex(x,y){ return { re: x, im: y }; }
function complexAdd(a,b){ return { re: a.re + b.re, im: a.im + b.im }; }
function complexSub(a,b){ return { re: a.re - b.re, im: a.im - b.im }; }
function complexScale(a, s){ return { re: a.re * s, im: a.im * s }; }
function complexMul(a,b){ return { re: a.re * b.re - a.im * b.im, im: a.re * b.im + a.im * b.re }; }
function complexConj(a){ return { re: a.re, im: -a.im }; }
function complexAbs2(a){ return a.re*a.re + a.im*a.im; }
function complexAbs(a){ return Math.sqrt(complexAbs2(a)); }

// ---------------- Canvas UI primitives (unchanged) ----------------
class UI { constructor(){ this.items=[]; this._active=null; } add(w){ this.items.push(w); w.ui=this; return w; } draw(){ for(const w of this.items) w.draw(); } mousePressed(){ for(let i=this.items.length-1;i>=0;i--){ const w=this.items[i]; if(w.mousePressed && w.contains(mouseX,mouseY)){ this._active=w; w.mousePressed(); return true; } } return false; } mouseDragged(){ if(this._active && this._active.mouseDragged) this._active.mouseDragged(); } mouseReleased(){ if(this._active && this._active.mouseReleased) this._active.mouseReleased(); this._active=null; return true; } syncFrom(app){ for(const w of this.items) if(w.syncFrom) w.syncFrom(app); } }

class UILabel { constructor(x,y,text){ this.x=x; this.y=y; this.text=text; this.h=24; } contains(){ return false; } draw(){ push(); noStroke(); fill(220); textSize(14); textAlign(LEFT,CENTER); text(this.text,this.x,this.y+12); pop(); } }

class UIButton {
  constructor(x,y,w,label,onClick){ this.x=x; this.y=y; this.w=w; this.h=28; this.label=label; this.onClick=onClick; this.down=false; }
  contains(px,py){ return px>=this.x && px<=this.x+this.w && py>=this.y && py<=this.y+this.h; }
  draw(){ const hover=this.contains(mouseX,mouseY); push(); noStroke(); fill(this.down?30:(hover?50:35)); rect(this.x,this.y,this.w,this.h,8); stroke(255,140); noFill(); rect(this.x,this.y,this.w,this.h,8); noStroke(); fill(255); textAlign(CENTER,CENTER); textSize(13); text(this.label,this.x+this.w/2,this.y+this.h/2); pop(); }
  mousePressed(){ this.down=true; }
  mouseReleased(){ if(this.down && this.contains(mouseX,mouseY) && this.onClick) this.onClick(); this.down=false; }
}

class UISlider {
  constructor(x,y,w,min,max,value,step,onChange){ this.x=x; this.y=y; this.w=w; this.h=24; this.min=min; this.max=max; this.value=value; this.step=step||0.01; this.onChange=onChange; this.grab=false; }
  contains(px,py){ return px>=this.x && px<=this.x+this.w && py>=this.y && py<=this.y+this.h; }
  _valToX(v){ return this.x + (this.w - 1) * ((v - this.min) / (this.max - this.min)); }
  _xToVal(px){ const t = constrain((px - this.x) / (this.w - 1), 0, 1); let v = this.min + t * (this.max - this.min); if (this.step > 0) v = Math.round(v / this.step) * this.step; return v; }
  draw(){ push(); stroke(120); strokeWeight(2); line(this.x,this.y+this.h/2,this.x+this.w,this.y+this.h/2); const kx = this._valToX(this.value); noStroke(); fill(230); circle(kx, this.y+this.h/2, 12); noStroke(); fill(220); textAlign(LEFT,CENTER); textSize(12); const dp = (this.step>=1)?0:(this.step>=0.1?1:2); text(this.value.toFixed(dp), this.x+this.w+8, this.y+this.h/2); pop(); }
  mousePressed(){ this.grab = true; this.value = this._xToVal(mouseX); if (this.onChange) this.onChange(this.value); }
  mouseDragged(){ if (!this.grab) return; this.value = this._xToVal(mouseX); if (this.onChange) this.onChange(this.value); }
  mouseReleased(){ this.grab = false; }
  syncFrom(){}
}

class UIStepper {
  constructor(x,y,w,value,step,min,max,onChange){ this.x=x; this.y=y; this.w=w; this.h=28; this.value=value; this.step=step||1; this.min=min??-Infinity; this.max=max??Infinity; this.onChange=onChange; this.btnW=28; this._dec=new UIButton(x,y,this.btnW,'â€“',()=>this._bump(-1)); this._inc=new UIButton(x+w-this.btnW,y,this.btnW,'+',()=>this._bump(+1)); }
  _bump(dir){ let v = this.value + dir * this.step; v = constrain(v, this.min, this.max); this.value = v; if (this.onChange) this.onChange(this.value); }
  contains(px,py){ return px>=this.x && px<=this.x+this.w && py>=this.y && py<=this.y+this.h; }
  draw(){ push(); noFill(); stroke(180,140); rect(this.x,this.y,this.w,this.h,6); noStroke(); fill(240); textAlign(CENTER,CENTER); textSize(13); text(this.value.toFixed(0), this.x+this.w/2, this.y+this.h/2); pop(); this._dec.draw(); this._inc.draw(); }
  mousePressed(){ if (this._dec.contains(mouseX,mouseY)) this._dec.mousePressed(); else if (this._inc.contains(mouseX,mouseY)) this._inc.mousePressed(); }
  mouseDragged(){}
  mouseReleased(){ if(this._dec.down) this._dec.mouseReleased(); if(this._inc.down) this._inc.mouseReleased(); }
  syncFrom(app){ const s=(this.onChange&&this.onChange.toString())||''; if (s.includes('param.start')) this.value = app.param.start; if (s.includes('param.dur')) this.value = app.param.dur; }
}
